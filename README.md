# Generated README

This Project README was generated by the Java 17 and JUnit 5 archetype.

Try the following commands:

```
mvn verify
mvn test
mvn checkstyle:checkstyle
mvn exec:java
mvn clean
```

Task 1: Implementing an Iterator (for ConsList.java)
Goal: Make a custom list iterable (i.e., you can loop through it).
What to Code:
Create a class called ConsIterator that implements Iterator<T>.
In the constructor, pass in the list you're iterating over.
hasNext() method: Check if the current element is not empty (use isEmpty()).
next() method: Return the current element (first()), then move to the next one (rest()).
Key Variables:
current: The list you're iterating through.
first(): Gets the first element in the list.
rest(): Moves to the next element.
java
Copy code
public class ConsIterator<T> implements Iterator<T> {
    private ConsList<T> current;  // The list we're iterating through

    public ConsIterator(ConsList<T> start) {
        this.current = start;  // Start from the first item
    }

    @Override
    public boolean hasNext() {
        return !current.isEmpty();  // Check if the list still has elements
    }

    @Override
    public T next() {
        T item = current.first();   // Get the current item
        current = current.rest();   // Move to the next item
        return item;
    }
}
Task 2: Make a Ball Bounce (in Ball.java)
Goal: Reverse the ball’s vertical velocity when it hits the ground.
What to Code:
In the bounce() method, check if py (position on the Y axis) is less than or equal to 0 and vy (vertical velocity) is negative.
If yes, reverse the vertical velocity (vy).
Key Variables:
py: The ball’s Y position.
vy: The ball’s vertical velocity.
java
Copy code
public Ball bounce() {
    if (this.py <= 0 && this.vy < 0) {    // Check if the ball is at the ground and moving down
        return new Ball(this.px, this.py, this.vx, -this.vy, this.color);  // Reverse the vertical velocity
    }
    return this;
}
Task 3: Delete Out-of-Bounds Balls (in App.java)
Goal: Remove balls that go out of bounds on the left or right of the window.

What to Code:

Inside onTick(), loop through the list of balls.
If the ball’s px() (X position) is within the window width, keep it.
Otherwise, remove the ball.
Key Variables:

px(): The ball's X position.
gw.getWidth(): Gets the window width to check boundaries.
java
Copy code
public void onTick(GfxWindow gw, long frame) {
    int width = gw.getWidth();    // Get the window width
    ConsList<Ball> balls1 = ConsList.empty();
    
    for (var ball : balls) {
        Ball newBall = ball.tick();   // Update the ball's position
        if (newBall.px() >= 0 && newBall.px() <= width) {   // Check if the ball is within the window boundaries
            balls1 = ConsList.cons(newBall, balls1);    // Keep the ball if it's in bounds
        }
    }
    this.balls = balls1;
    gw.putShapes(this.getCircles());
}
Task 4: Create a Square Shape (in SimpleShape.java)
Goal: Draw a square using the Square class.

What to Code:

Create a Square class that implements SimpleShape.
Use Rectangle2D.Double to draw the square.
Implement the flipY() method to handle the Y axis flipping (like the Circle class).
Key Variables:

side: The side length of the square.
Rectangle2D.Double: Used to draw the square.
java
Copy code
record Square(double x, double y, double side, Color color) implements SimpleShape {
    @Override
    public Shape toShape() {
        return new Rectangle2D.Double(x-side/2, y-side/2, side, side);  // Create the square at x, y with a given side length
    }

    @Override
    public SimpleShape flipY(int hh) {
        return new Square(x, hh - y, side, color);  // Flip the Y axis
    }
}
General Tips for Remembering Variables and Logic:
Use Descriptive Names: Even in practice, use variable names that describe what they do. This makes it easier to recall later.
Draw it Out: For concepts like bouncing, draw a ball hitting the ground to visualize how you should code the logic.
Comment While Practicing: Add comments for yourself as you write, even if you remove them later in final versions.
Ask "Why": For each line of code, think about why it's necessary (e.g., "Why do I need to check py <= 0?").











ConsList.java
java
Copy code
package lab05;

import java.util.Iterator;

/**
 * Implements a generic linked list.
 *
 * @param  <T>  Type of list items
 *
 * @author Nat Tuck
 */
public interface ConsList<T> extends Iterable<T> {
    /**
     * Creates a list of the given items.
     *
     * @param  <T>   ConsList item type
     * @param  args  Zero or more items
     * @return       A list of those items
     */
    @SafeVarargs
    public static <T> ConsList<T> of(T... args) {
        ConsList<T> ys = new Empty<T>();
        for (int ii = args.length - 1; ii >= 0; --ii) {
            ys = new Cell<T>(args[ii], ys);
        }
        return ys;
    }

    /**
     * Create empty list.
     *
     * @param  <T>   Item type
     * @return       Empty list
     */
    public static <T> ConsList<T> empty() {
        return new Empty<T>();
    }

    /**
     * Add item at start of list.
     *
     * @param  <T>   Item type
     * @param  item  Item to add
     * @param  list  List to add item to
     * @return       New list with item added
     */
    public static <T> ConsList<T> cons(T item, ConsList<T> list) {
        return new Cell<T>(item, list);
    }

    /**
     * Get the first item in the list.
     *
     * @return  The first item
     */ 
    T first();

    /**
     * Get a list of all items except the first.
     *
     * @return  The rest of the list
     */
    ConsList<T> rest();

    /**
     * Determine if the list is empty.
     *
     * @return  True for empty list, else false.
     */
    boolean isEmpty();

    /**
     * Determine the length of the list.
     *
     * @return  ConsList length
     */
    int size();

    /**
     * Create a new list with items in reverse order.
     *
     * @return   New reversed list
     */
    ConsList<T> reverse();

    @Override
    default public ConsIterator<T> iterator() {
        return new ConsIterator<T>(this);
    }
}

/**
 * Implementation of the ConsIterator class for iterating over a ConsList.
 *
 * @param <T> The type of elements in the list
 */
class ConsIterator<T> implements Iterator<T> {
    private ConsList<T> current;

    public ConsIterator(ConsList<T> start) {
        this.current = start;
    }

    @Override
    public boolean hasNext() {
        return !current.isEmpty();
    }

    @Override
    public T next() {
        T item = current.first();
        current = current.rest();
        return item;
    }
}
Ball.java
java
Copy code
package lab05;

import java.awt.Color;

public class Ball {
    private double px;
    private double py;
    private double vx;
    private double vy;
    private Color color;

    public Ball(double px, double py, double vx, double vy, Color color) {
        this.px = px;
        this.py = py;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
    }

    public double px() {
        return px;
    }

    public double py() {
        return py;
    }

    public double vx() {
        return vx;
    }

    public double vy() {
        return vy;
    }

    public Color color() {
        return color;
    }

    public Ball tick() {
        this.px += this.vx;
        this.py += this.vy;
        this.vy -= App.GRAVITY; // Apply gravity
        return this.bounce(); // Call bounce to check for ground collision
    }

    public Ball bounce() {
        if (this.py <= 0 && this.vy < 0) {
            return new Ball(this.px, this.py, this.vx, -this.vy, this.color);
        }
        return this;
    }

    public Circle toCircle() {
        return new Circle(px, py, 50, color);
    }
    
    public static Ball random(int x, int y) {
        return new Ball(x, y, Math.random() * 10 - 5, Math.random() * 10 - 5, Color.blue);
    }
}
SimpleShape.java
java
Copy code
package lab05;

import java.awt.Color;
import java.awt.Shape;
import java.awt.geom.*;

public interface SimpleShape {
    Color color();
    Shape toShape();
    SimpleShape flipY(int hh);
}

record Circle(double x, double y, double radius, Color color) implements SimpleShape {
    @Override
    public Shape toShape() {
        return new Ellipse2D.Double(x-radius, y-radius, 2*radius, 2*radius);
    }

    @Override
    public SimpleShape flipY(int hh) {
        return new Circle(x, hh - y, radius, color);
    }
}

record Square(double x, double y, double side, Color color) implements SimpleShape {
    @Override
    public Shape toShape() {
        return new Rectangle2D.Double(x-side/2, y-side/2, side, side);
    }

    @Override
    public SimpleShape flipY(int hh) {
        return new Square(x, hh - y, side, color);
    }
}